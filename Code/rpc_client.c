/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

void printError(char *error_msg);
void menu_prog_1(char *host, int newSock);

int main (int argc, char *argv[])
{
/*  
 *  Variable declarations
 */
	char *serverHost;
	int sock, newSock, portNo, clientLen, pid;
	int bindStatus, listenStatus, closeStatus, sendStatus;
	struct sockaddr_in serverAddr, clientAddr;
/*  
 *  Check for the port number and host for connecting to the socket server 
 */
	if (argc < 3) 
	{
		fprintf (stderr, "usage: %s portNo serverHost\n", argv[0]);
		exit (1);
	}
/*  
 *  Open the socket server
 */ 
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		printError("Error on opening socket... socket() failed to execute\n"); 
/*
 *  Configure settings for the TCP connection between socket client and socket server
 */ 
	bzero((char *) &serverAddr, sizeof(serverAddr));
	portNo = atoi(argv[1]);
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(portNo);
	serverAddr.sin_addr.s_addr = INADDR_ANY;
/*
 *  Bind the socket server to the port number
 */ 
	bindStatus = bind(sock, (struct sockaddr *) &serverAddr, sizeof(serverAddr));
	if (bindStatus < 0)
		printError("Error on binding socket... bind() failed to execute.\n");
/*
 *  Wait for incoming requests from socket clients
 */
	listenStatus = listen(sock, 5);
	if (listenStatus < 0)
		printError("Error on listening to incoming connections from clients... listen() failed to execute.\n");
/*
 *  Handle a socket clientâ€™s request to connect to the socket server with the associated port number
 */	
	for (;;)
	{
/*
 *  Accept the request and start the TCP connection between the requesting socket client
 *  and the socket server by creating a new socket
 */
		clientLen = sizeof(clientAddr);
		newSock = accept(sock, (struct sockaddr *) &clientAddr, &clientLen);
		if (newSock < 0)
			printError("Error on accepting incoming connection from a client... accept() failed to execute.\n");
/*
 *  Create a new child process 
 */
		pid = fork();
		if (pid < 0)
			printError("Child process was not created... fork() failed to execute.\n");
/*
 *  Code that will be executed only by the child process
 */
		if (pid == 0)
		{
/*
 *  Close the parent process socket
 */
			closeStatus = close(sock);
			if (closeStatus < 0)
				printError("Error on closing the socket... close() failed to execute.\n");
/*
 *  Call the function that handles rpc communication handlers for calling rpc routines
 *  to calculate the results requested by the socket client through the rpc server
 */
			serverHost = argv[2];
			menu_prog_1(serverHost, newSock);
/*
 *  Close the new socket that was created when the TCP connection between socket client and socket server was established
 */
			close(newSock);
/*
 *  Terminate the code of the child process
 */
			exit(0);
		}
	}
/*
 *  Terminate the code of the parent process
 */
	exit(0);
}

/*  
 *  Print an error message in case of function execution failure
 */
void printError(char *error_msg)
{
	fprintf(stderr, "%s\n", error_msg);
	exit(1);
}


/*
 *  The function that handles RPC communication handlers for calling RPC routines 
 *  that will compute the results requested by the socket client through the RPC server
 */
void menu_prog_1(char *host, int newSock)
{
/*  
 *  Variable declarations
 */
	CLIENT *clnt;
	int  *result_1;
	inputData  innerproduct_1_arg;
	avgArray  *result_2;
	inputData  averages_1_arg;
	productVector  *result_3;
	inputData  product_1_arg;
	int i; 
	int sendStatus, recvStatus;
	int clientN, clientChoice, clientPid;
	int *clientX, *clientY;
	double clientR;
/*
 *  Receive the ID of the socket client
 */	
	recvStatus = recv(newSock, &clientPid, sizeof(int), 0);
	if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *  Print confirmation message of the TCP connection between the socket client and the socket server,
 *  with the printed socket client ID clarifying which socket client is requesting 
 *  the desired results from the socket server. The reason the socket server receives the
 *  socket client ID is to handle requests from multiple socket clients that are connected.
 */	
	printf("[Connection] : socket client with ID %d has been connected.\n", clientPid);
/*
 *  Receive the data from the requesting socket client, call the RPC routine via the 
 *  RPC server based on the socket client's choice from the menu, receive the results
 *  from the RPC server, print the results, and send them to the socket client.
 */
	do
	{
/*
 *  Receive the choice from the menu, from the requesting socket client
 */
		recvStatus = recv(newSock, &clientChoice, sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *  Receive the size \(N\) of the vectors, from the requesting socket client
 */
		recvStatus = recv(newSock, &clientN, sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *  Receive the double value \(r\), from the requesting socket client
 */		
		recvStatus = recv(newSock, &clientR, sizeof(double), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *  Receive vector \(X\), from the requesting socket client
 */	
		clientX = (int *) malloc(clientN * sizeof(int));
		if (clientX == NULL)
			printError("Error on allocating memory...\n");
		recvStatus = recv(newSock, clientX, clientN * sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *  Receive vector \(Y\), from the requesting socket client
 */		
		clientY = (int *) malloc(clientN * sizeof(int));
		if (clientY == NULL)
			printError("Error on allocating memory...\n");
		recvStatus = recv(newSock, clientY, clientN * sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *  Select the RPC routine call based on the socket client's choice, 
 *  which will be executed by the RPC server.
 */			
		switch (clientChoice)
		{
/*
 *  The socket client chose option 
 *  [1] Inner product of vectors \(X * Y\)
 */	
			case 1 :
#ifndef	DEBUG
				clnt = clnt_create (host, MENU_PROG, MENU_VER, "udp");
				if (clnt == NULL) 
				{
					printf("Error on creating RPC server communication handler.\n");
					clnt_pcreateerror (host);
					exit (1);
				}
#endif	/* DEBUG */
/*
 *  Initialize the data with the appropriate structures for the RPC communication
 */
				printf("[%d]\t[1] Inner product of X * Y\n", clientPid);
				printf("\tSending socket client's data to RPC server, waiting for results...\n");
				innerproduct_1_arg.X.X_len = clientN;
				innerproduct_1_arg.X.X_val = (int *) malloc (clientN * sizeof(int));
				if (innerproduct_1_arg.X.X_val == NULL)
					printError("Error on allocating memory.\n");
				innerproduct_1_arg.Y.Y_len = clientN;
				innerproduct_1_arg.Y.Y_val = (int *) malloc (clientN * sizeof(int));
				if (innerproduct_1_arg.Y.Y_val == NULL)
					printError("Error on allocating memory.\n");
				for (i = 0; i < clientN; i++)
				{
					innerproduct_1_arg.X.X_val[i] = clientX[i];
					innerproduct_1_arg.Y.Y_val[i] = clientY[i];
				}
				innerproduct_1_arg.r = clientR;
/*
 *  Call the RPC routine "innerproduct_1", which is executed by the RPC server and
 *  returns the result to the RPC client
 */				
				result_1 = innerproduct_1(&innerproduct_1_arg, clnt);
				printf("\t---------------- Results -----------------\n");
				printf("\tX * Y : %d\n", *result_1);
				if (result_1 == (int *) NULL) 
					clnt_perror (clnt, "call failed");
/*
 *  Send the results "[1] Inner product of vectors \(X * Y\)" to the socket client
 */
				printf("\tSending results to socket client with ID %d.\n", clientPid);
				sendStatus = send(newSock, result_1, sizeof(int), 0);
				if (sendStatus < 0)
					printError("Error on sending the results to socket client... send() failed to execute.\n");
				free(innerproduct_1_arg.X.X_val);
				free(innerproduct_1_arg.Y.Y_val);
#ifndef	DEBUG
				clnt_destroy (clnt);
#endif	 /* DEBUG */
				break;
			case 2 :
/*
 *  The socket client chose option 
 *  [2] Average value of each vector
 */
#ifndef	DEBUG
				clnt = clnt_create (host, MENU_PROG, MENU_VER, "udp");
				if (clnt == NULL) 
				{
					printf("Error on creating RPC server communication handler.\n");
					clnt_pcreateerror (host);
					exit(1);
				}
#endif	/* DEBUG */
/*
 *  Initialize the data with the appropriate structures for the RPC communication
 */		
				printf("[%d]\t[2] Average value of each vector\n", clientPid);
				printf("\tSending socket client's data to RPC server, waiting for results...\n");
				averages_1_arg.X.X_len = clientN;
				averages_1_arg.X.X_val = (int *) malloc (clientN * sizeof(int));
				if (averages_1_arg.X.X_val == NULL)
					printError("Error on allocating memory.\n");
				averages_1_arg.Y.Y_len = clientN;
				averages_1_arg.Y.Y_val = (int *) malloc (clientN * sizeof(int));
				if (averages_1_arg.Y.Y_val == NULL)
					printError("Error on allocating memory.\n");
				for (i = 0; i < clientN; i++)
				{
					averages_1_arg.X.X_val[i] = clientX[i];
					averages_1_arg.Y.Y_val[i] = clientY[i];
				}
				averages_1_arg.r = clientR;
/*
 *  Call the RPC routine "averages_1", which is executed by the RPC server and
 *  returns the result to the RPC client
 */
				result_2 = averages_1(&averages_1_arg, clnt);
				printf("\t---------------- Results -----------------\n");
				printf("\tAverage value of X : %lf\n", result_2->arr[0]);
				printf("\tAverage value of Y : %lf\n", result_2->arr[1]);
				if (result_2 == (avgArray *) NULL) 
					clnt_perror (clnt, "call failed");
/*
 *  Send the results "[2] Average value of each vector" to the socket client
 */				
				printf("\tSending results to socket client with ID %d.\n", clientPid);
				sendStatus = send(newSock, result_2->arr, 2 * sizeof(double), 0);
				if (sendStatus < 0)
					printError("Error on sending the results to socket client... send() failed to execute.\n");
				free(averages_1_arg.X.X_val);
				free(averages_1_arg.Y.Y_val);
#ifndef	DEBUG
				clnt_destroy (clnt);
#endif	 /* DEBUG */
				break;
			case 3 :
/*
 *  The socket client chose option 
 *  [3] Product of \(r * (X + Y)\)
 */
#ifndef	DEBUG
				clnt = clnt_create (host, MENU_PROG, MENU_VER, "udp");
				if (clnt == NULL) 
				{
					printf("Error on creating RPC server communication handler.\n");
					clnt_pcreateerror (host);
					exit (1);
				}
#endif	/* DEBUG */
/*
 *  Initialize the data with the appropriate structures for the RPC communication
 */				
				printf("[%d]\t[3] Product of \(r * (X + Y)\)\n", clientPid);
				printf("\tSending socket client's data to RPC server, waiting for results...\n");
				product_1_arg.X.X_len = clientN;
				product_1_arg.X.X_val = (int *) malloc (clientN * sizeof(int));
				if (product_1_arg.X.X_val == NULL)
					printError("Error on allocating memory.\n");
				product_1_arg.Y.Y_len = clientN;
				product_1_arg.Y.Y_val = (int *) malloc (clientN * sizeof(int));
				if (product_1_arg.Y.Y_val == NULL)
					printError("Error on allocating memory.\n");
				for (i = 0; i < clientN; i++)
				{
					product_1_arg.X.X_val[i] = clientX[i];
					product_1_arg.Y.Y_val[i] = clientY[i];
				}
				product_1_arg.r = clientR;
/*
 *  Call the RPC routine "product_1", which is executed by the RPC server and
 *  returns the result to the RPC client
 */
				result_3 = product_1(&product_1_arg, clnt);
				printf("\t---------------- Results -----------------\n");
				for (i = 0; i < clientN; i++)
					printf("\tr * (X + Y)[%d] : %lf\n", i, result_3->vec.vec_val[i]);
				if (result_3 == (productVector *) NULL) 
					clnt_perror (clnt, "call failed");
/*
 *  Send the results "[3] Product of \(r * (X + Y)\)" to the socket client
 */				
				printf("\tSending results to socket client with ID %d.\n", clientPid);
				sendStatus = send(newSock, result_3->vec.vec_val, sizeof(double) * clientN, 0);
				if (sendStatus < 0)
					printError("Error on sending the results to socket client... send() failed to execute.\n");
				free(product_1_arg.X.X_val);
				free(product_1_arg.Y.Y_val);
#ifndef	DEBUG
				clnt_destroy (clnt);
#endif	 /* DEBUG */
				break;
			case 4 :
/*
 *  The socket client chose option 
 *  [4] Exit
 */
				printf("[%d]\t[4] Exit\n", clientPid);
				printf("[Disconnection] : socket client with ID %d has been disconnected.\n", clientPid);
				break;
		}	
	} while (clientChoice != 4);
}




