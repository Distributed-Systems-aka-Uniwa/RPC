/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

void printError(char *error_msg);
void menu_prog_1(char *host, int newSock);

int main (int argc, char *argv[])
{
/*  
 *  Δήλωση μεταβλητών
 */
	char *serverHost;
	int sock, newSock, portNo, clientLen, pid;
	int bindStatus, listenStatus, closeStatus, sendStatus;
	struct sockaddr_in serverAddr, clientAddr;
/*  
 *  Έλεγχος για εισαγωγή του port number και του host για σύνδεση στον socket server 
 */
	if (argc < 3) 
	{
		fprintf (stderr, "usage: %s portNo serverHost\n", argv[0]);
		exit (1);
	}
/*  
 *  Άνοιγμα του socket server
 */ 
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		printError("Error on opening socket... socket() failed to execute\n"); 
/*
 *  Παραμετροποίηση μέτρων για την TCP σύνδεση socket client με socket server
 */ 
	bzero((char *) &serverAddr, sizeof(serverAddr));
	portNo = atoi(argv[1]);
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(portNo);
	serverAddr.sin_addr.s_addr = INADDR_ANY;
/*
 *  Συσχέτιση του socket server με το port number
 */ 
	bindStatus = bind(sock, (struct sockaddr *) &serverAddr, sizeof(serverAddr));
	if (bindStatus < 0)
		printError("Error on binding socket... bind() failed to execute.\n");
/*
 *  Αναμονή για εισερχόμενες αιτήσεις από socket clients
 */
	listenStatus = listen(sock, 5);
	if (listenStatus < 0)
		printError("Error on listening incoming connections from clients... listen() failed to execute.\n");
/*
 *  Διαχείριση του αιτήματος ενός socket client για σύνδεση στον socker server με το port number που έχει συσχετιστεί
 */	
	for (;;)
	{
/*
 *  Αποδοχή του αιτήματος και έναρξη TCP σύνδεσης του αιτούμενου socket client  
 *  με τον socket server με την δημιουργία νέου socket 
 */
		clientLen = sizeof(clientAddr);
		newSock = accept(sock, (struct sockaddr *) &clientAddr, &clientLen);
		if (newSock < 0)
			printError("Error on accepting incoming connection from a client... accept() failed to execute.\n");
/*
 *  Δημιουργία νέας διεργασίας-παιδί 
 */
		pid = fork();
		if (pid < 0)
			printError("Child process was not created... fork() failed to execute.\n");
/*
 *  Κώδικας που θα εκτελέσει μόνο η διεργασία παιδί
 */
		if (pid == 0)
		{
/*
 *  Κλείσιμο του socket της διεργασίας γονέα 
 */
			closeStatus = close(sock);
			if (closeStatus < 0)
				printError("Error on closing the socket... close() failed to execute.\n");
/*
 *  Κλήση της συνάρτησης που χειρίζεται rpc communication handlers για την κλήση rpc ρουτινών 
 *  που θα υπολογίζουν μέσω του rpc server, τα αποτελέσματα που επιθυμεί ο socket client
 */
			serverHost = argv[2];
			menu_prog_1 (serverHost, newSock);
/*
 *  Κλείσιμο του νέου socket που δημιουργήθηκε με την έναρξη της 
 *  TCP σύνδεσης socket client-socket server
 */
			close(newSock);
/*
 *  Τερματισμός του κώδικα της διεργασίας-παιδί
 */
			exit(0);
		}
	}
/*
 *  Τερματισμός του κώδικα της διεργασίας-γονέα
 */
	exit(0);
}

/*  
 *  Εκτύπωση σφάλματος σε περίπτωση αποτυχίας εκτέλεσης κάποιας συνάρτησης 
 */
void printError(char *error_msg)
{
	fprintf(stderr, "%s\n", error_msg);
	exit(1);
}

/*
 *  Η συνάρτηση που χειρίζεται rpc communication handlers για την κλήση rpc ρουτινών 
 *  που θα υπολογίζουν μέσω του rpc server, τα αποτελέσματα που επιθυμεί ο socket client
 */
void menu_prog_1(char *host, int newSock)
{
/*  
 *  Δήλωση μεταβλητών
 */
	CLIENT *clnt;
	int  *result_1;
	inputData  innerproduct_1_arg;
	avgArray  *result_2;
	inputData  averages_1_arg;
	productVector  *result_3;
	inputData  product_1_arg;
	int i; 
	int sendStatus, recvStatus;
	int clientN, clientChoice, clientPid;
	int *clientX, *clientY;
	double clientR;
/*
 * 	Παραλαβή του id του socket client
 */	
	recvStatus = recv(newSock, &clientPid, sizeof(int), 0);
	if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 * 	Εκτύπωση μηνύματος επιβεβαίωσης της TCP σύνδεσης socket client με τον socket server,
 *  με την εκτύπωση του socket client id να αποσαφηνίζει ποιος socket client αιτείται 
 *  επιθυμητά αποτελέσματα από τον socket server. Ο λόγος που ο socket server λαμβάνει και
 *  το socket client id είναι η συμφόρηση της εξυπηρέτησης αιτήσεων πολλαπλών socket client 
 *  που έχουν συνδεθεί
 */	
	printf("[Connection] : socket client with Id %d has been connected.\n", clientPid);
/*
 *  Παραλαβή των δεδομένων από τον αιτούμενο socket client, κλήση της rpc ρουτίνας μέσω του 
 *  rpc server με βάση την επιλογή του socket client από το μενού, παραλαβή αποτελεσμάτων
 *  από τον rpc server, εκτύπωση αποτελεσμάτων και αποστολή στον socket client
 */
	do
	{
/*
 *  Παραλαβή της επιλογής από το μενού, από τον αιτούμενο socket client
 */
		recvStatus = recv(newSock, &clientChoice, sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *	Παραλαβή του μεγέθους Ν των διανυσμάτων, από τον αιτούμενο socket client
 */
		recvStatus = recv(newSock, &clientN, sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *	Παραλαβή της πραγματικής τιμής r, από τον αιτούμενο socket client
 */		
		recvStatus = recv(newSock, &clientR, sizeof(double), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *	Παραλαβή του διανύσματος Χ, από τον αιτούμενο socket client
 */	
		clientX = (int *) malloc(clientN * sizeof(int));
		if (clientX == NULL)
			printError("Error on allocating memory...\n");
		recvStatus = recv(newSock, clientX, clientN * sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *	Παραλαβή του διανύσματος Υ, από τον αιτούμενο socket client
 */		
		clientY = (int *) malloc(clientN * sizeof(int));
		if (clientY == NULL)
			printError("Error on allocating memory...\n");
		recvStatus = recv(newSock, clientY, clientN * sizeof(int), 0);
		if (recvStatus < 0)
			printError("Error on receiving data from client... recv() failed to execute\n");
/*
 *	Επιλογή κλήσης της rpc ρουτίνας ανάλογα την επιλογή του socket client, 
 *  με την οποία θα εκτελέσει ο rpc server
 */			
		switch (clientChoice)
		{
/*
 * 	Ο socket client επέλεξε την επιλογή 
 *  [1] Εσωτερικό γινόμενο των διανυσμάτων Χ * Υ
 */	
			case 1 :
#ifndef	DEBUG
				clnt = clnt_create (host, MENU_PROG, MENU_VER, "udp");
				if (clnt == NULL) 
				{
					printf("Error on creating rpc server communication handler.\n");
					clnt_pcreateerror (host);
					exit (1);
				}
#endif	/* DEBUG */
/*
 *  Αρχικοποίηση των δεδομένων με τις κατάλληλες δομές για την rpc επικοινωνία
 */
				printf("[%d]\t[1] Inner product of X * Y\n", clientPid);
				printf("\tSending socket client's data to rpc server, waiting for results...\n");
				innerproduct_1_arg.X.X_len = clientN;
				innerproduct_1_arg.X.X_val = (int *) malloc (clientN * sizeof(int));
				if (innerproduct_1_arg.X.X_val == NULL)
					printError("Error on allocating memory.\n");
				innerproduct_1_arg.Y.Y_len = clientN;
				innerproduct_1_arg.Y.Y_val = (int *) malloc (clientN * sizeof(int));
				if (innerproduct_1_arg.Y.Y_val == NULL)
					printError("Error on allocating memory.\n");
				for (i = 0; i < clientN; i++)
				{
					innerproduct_1_arg.X.X_val[i] = clientX[i];
					innerproduct_1_arg.Y.Y_val[i] = clientY[i];
				}
				innerproduct_1_arg.r = clientR;
/*
 * 	Κλήση της rpc ρουτίνας "innerproduct_1", η οποία εκτελείται από τον rpc server που
 *  επιστρέφει το αποτέλεσμα στον rpc client
 */				
				result_1 = innerproduct_1(&innerproduct_1_arg, clnt);
				printf("\t---------------- Results -----------------\n");
				printf("\tX * Y : %d\n", *result_1);
				if (result_1 == (int *) NULL) 
					clnt_perror (clnt, "call failed");
/*
 *	Αποστολή των αποτελεσμάτων "[1] Εσωτερικό γινόμενο των διανυσμάτων Χ * Υ" στον socket client
 */
				printf("\tSending results to socket client with Id %d.\n", clientPid);
				sendStatus = send(newSock, result_1, sizeof(int), 0);
				if (sendStatus < 0)
					printError("Error on sending the results to socket client... send() failed to execute.\n");
				free(innerproduct_1_arg.X.X_val);
				free(innerproduct_1_arg.Y.Y_val);
#ifndef	DEBUG
				clnt_destroy (clnt);
#endif	 /* DEBUG */
				break;
			case 2 :
/*
 * 	Ο socket client επέλεξε την επιλογή 
 *  [2] Μέση τιμή κάθε διανύσματος
 */
#ifndef	DEBUG
				clnt = clnt_create (host, MENU_PROG, MENU_VER, "udp");
				if (clnt == NULL) 
				{
					printf("Error on creating rpc server communication handler.\n");
					clnt_pcreateerror (host);
					exit(1);
				}
#endif	/* DEBUG */
/*
 *  Αρχικοποίηση των δεδομένων με τις κατάλληλες δομές για την rpc επικοινωνία
 */		
				printf("[%d]\t[2] Average value of each vector\n", clientPid);
				printf("\tSending socket client's data to rpc server, waiting for results...\n");
				averages_1_arg.X.X_len = clientN;
				averages_1_arg.X.X_val = (int *) malloc (clientN * sizeof(int));
				if (averages_1_arg.X.X_val == NULL)
					printError("Error on allocating memory.\n");
				averages_1_arg.Y.Y_len = clientN;
				averages_1_arg.Y.Y_val = (int *) malloc (clientN * sizeof(int));
				if (averages_1_arg.Y.Y_val == NULL)
					printError("Error on allocating memory.\n");
				for (i = 0; i < clientN; i++)
				{
					averages_1_arg.X.X_val[i] = clientX[i];
					averages_1_arg.Y.Y_val[i] = clientY[i];
				}
				averages_1_arg.r = clientR;
/*
 * 	Κλήση της rpc ρουτίνας "averages_1", η οποία εκτελείται από τον rpc server που
 *  επιστρέφει το αποτέλεσμα στον rpc client
 */
				result_2 = averages_1(&averages_1_arg, clnt);
				printf("\t---------------- Results -----------------\n");
				printf("\tAverage value of X : %lf\n", result_2->arr[0]);
				printf("\tAverage value of Y : %lf\n", result_2->arr[1]);
				if (result_2 == (avgArray *) NULL) 
					clnt_perror (clnt, "call failed");
/*
 *	Αποστολή των αποτελεσμάτων "[2] Μέση τιμή κάθε διανύσματος" στον socket client
 */				
				printf("\tSending results to socket client with Id %d.\n", clientPid);
				sendStatus = send(newSock, result_2->arr, 2 * sizeof(double), 0);
				if (sendStatus < 0)
					printError("Error on sending the results to socket client... send() failed to execute.\n");
				free(averages_1_arg.X.X_val);
				free(averages_1_arg.Y.Y_val);
#ifndef	DEBUG
				clnt_destroy (clnt);
#endif	 /* DEBUG */
				break;
			case 3 :
/*
 * 	Ο socket client επέλεξε την επιλογή 
 *  [3] Γινόμενο r * (X + Y)
 */
#ifndef	DEBUG
				clnt = clnt_create (host, MENU_PROG, MENU_VER, "udp");
				if (clnt == NULL) 
				{
					printf("Error on creating rpc server communication handler.\n");
					clnt_pcreateerror (host);
					exit (1);
				}
#endif	/* DEBUG */
/*
 *  Αρχικοποίηση των δεδομένων με τις κατάλληλες δομές για την rpc επικοινωνία
 */				
				printf("[%d]\t[3] Product of r * (X + Y)\n", clientPid);
				printf("\tSending socket client's data to rpc server, waiting for results...\n");
				product_1_arg.X.X_len = clientN;
				product_1_arg.X.X_val = (int *) malloc (clientN * sizeof(int));
				if (product_1_arg.X.X_val == NULL)
					printError("Error on allocating memory.\n");
				product_1_arg.Y.Y_len = clientN;
				product_1_arg.Y.Y_val = (int *) malloc (clientN * sizeof(int));
				if (product_1_arg.Y.Y_val == NULL)
					printError("Error on allocating memory.\n");
				for (i = 0; i < clientN; i++)
				{
					product_1_arg.X.X_val[i] = clientX[i];
					product_1_arg.Y.Y_val[i] = clientY[i];
				}
				product_1_arg.r = clientR;
/*
 * 	Κλήση της rpc ρουτίνας "product_1", η οποία εκτελείται από τον rpc server που
 *  επιστρέφει το αποτέλεσμα στον rpc client
 */
				result_3 = product_1(&product_1_arg, clnt);
				printf("\t---------------- Results -----------------\n");
				for (i = 0; i < clientN; i++)
					printf("\tr * (X + Y)[%d] : %lf\n", i, result_3->vec.vec_val[i]);
				if (result_3 == (productVector *) NULL) 
					clnt_perror (clnt, "call failed");
/*
 *	Αποστολή των αποτελεσμάτων "[3] Γινόμενο r * (X + Y)" στον socket client
 */				
				printf("\tSending results to socket client with Id %d.\n", clientPid);
				sendStatus = send(newSock, result_3->vec.vec_val, sizeof(double) * clientN, 0);
				if (sendStatus < 0)
					printError("Error on sending the results to socket client... send() failed to execute.\n");
				free(product_1_arg.X.X_val);
				free(product_1_arg.Y.Y_val);
#ifndef	DEBUG
				clnt_destroy (clnt);
#endif	 /* DEBUG */
				break;
			case 4 :
/*
 * 	Ο socket client επέλεξε την επιλογή 
 *  [4] Έξοδος
 */
				printf("[%d]\t[4] Exit\n", clientPid);
				printf("[Disconnection] : socket client with Id %d has been disconnected.\n", clientPid);
				break;
		}	
	} while (clientChoice != 4);
}



